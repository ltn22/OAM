<?xml version='1.0' encoding='utf-8'?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
    please see http://xml.resource.org/authoring/README.html. -->
<rfc
      xmlns:xi="http://www.w3.org/2001/XInclude"
      category="info"
      docName="draft-barthel-schc-oam-schc-03"
      ipr="trust200902"
      obsoletes=""
      updates=""
      submissionType="IETF"
      xml:lang="en"
      tocInclude="true"
      tocDepth="4"
      symRefs="true"
      sortRefs="true"
      version="3">
  <!-- xml2rfc v2v3 conversion 2.38.1 -->
  <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN" 
    they will automatically be output with "(if approved)" -->

 <!-- ***** FRONT MATTER ***** -->

<front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
        full title is longer than 39 characters -->

  <title abbrev="SCHC ICMPv6 Compression">Static Context Header Compression (SCHC) for the Internet Control Message Protocol (ICMPv6)</title>
  <seriesInfo name="Internet-Draft" value="draft-barthel-schc-oam-schc-03"/>

  <!-- add 'role="editor"' below for the editors if appropriate -->
  <!--author fullname="Dominique Barthel" initials="D." role="editor" surname="Barthel"-->
  <author fullname="Dominique Barthel" initials="D." surname="Barthel">
    <organization></organization>
    <address>
      <postal>
        <country>France</country>
      </postal>
      <email>dominique.barthel@orange.com</email>
    </address>
  </author>

  <author fullname="Laurent Toutain" initials="L." surname="Toutain">
    <organization>IMT Atlantique</organization>
    <address>
      <postal>
        <street>2 rue de la Chataigneraie</street> <street>CS 17607</street>
        <city>Cesson-Sevigne Cedex</city>
        <code>35576</code>
        <country>France</country>
      </postal>
      <email>laurent.toutain@imt-atlantique.fr</email>
    </address>
  </author>

<!--  *****
  <author fullname="Arunprabhu Kandasamy" initials="A." surname="Kandasamy">
    <organization>Acklio</organization>
    <address>
      <postal>
        <street>1137A avenue des Champs Blancs</street>
        <city>Cesson-Sevigne Cedex</city>
        <code>35510</code>
        <country>France</country>
      </postal>
      <email>arun@ackl.io</email>
    </address>
  </author>

  <author fullname="Diego Dujovne" initials="D." surname="Dujovne">
    <organization>Universidad Diego Portales</organization>
    <address>
      <postal>
        <street>Vergara 432</street>
        <city>Santiago</city>
        <code></code>
        <country>Chile</country>
      </postal>
      <email>diego.dujovne@mail.udp.cl</email>
    </address>
  </author>

  <author fullname="Juan Carlos Zuniga" initials="JC." surname="Zuniga">
    <organization>Cisco</organization>
    <address>
      <postal>
        <street></street>
        <city>Montreal QC</city>
        <code></code>
        <country>Canada</country>
      </postal>
      <email>juzuniga@cisco.com</email>
    </address>
  </author>
 ***** -->
 
  <date year="2024"/>
  <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
        in the current day for you. If only the current year is specified, xml2rfc will fill 
	in the current day and month for you. If the year is not the current one, it is 
	necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	specify just the year. -->

  <!-- Meta-data Declarations -->

  <area>Internet</area>
  <workgroup>schc Working Group</workgroup>
  <!-- WG name at the upperleft corner of the doc,
        IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->

  <keyword>template</keyword>
  <!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->

  <abstract>

    <t>This document describes how the ICMPv6 protocol can be integrated into the SCHC architecture.  
    It extends the YANG Data Model decribed in  <xref target="RFC9363"/> with new field IDs specific 
    to ICMPv6 headers as defined in <xref target="RFC4443"/>. </t>
  
  <t>To enhance the compression of ICMPv6 error messages, the document also introduces 
  two new Matching Operators and two Compression Decompression Actions to manipulate the ICMPv6 payload.   </t>

  <t>Finally, for constrained networks such as LPWAN, it introduces a proxy behavior, where 
  a SCHC Core end-point may anticipate the device reaction to incorrect messages.</t>
 
  </abstract>
</front>

<middle>
<section anchor="introduction" numbered="true" toc="default">
<name>Introduction</name>


     <t>
    Applying SCHC compression to IPv6 networks, users expect to perform control operations 
    such as ping to ensure that devices are still active. In the same way, ICMPv6 error 
    message can be helpful for the Device with may adapt its behavior when the Application 
    becomes unreachable. The Application may also benefit from the ICMPv6 error message 
    produced by the SCHC entity when compression is not possible.</t>

<!--    <t>However, this requires a little care, because ICMPv6 traffic adds load to the network,
	  and LPWANs could easily be overwhelmed by it.
	  LPWANs’ salient characteristics are described in <xref target="RFC8376"/>.</t>
-->

	<t>
 The compression described in this document is not limited to traffic over LPWANs, but can
 be applied to any kind of network. The ICMPv6 messages covered by this document are those
  defined in ICMPv6 protocol <xref target="RFC4443"/>. The compression described in this 
  document does not cover other ICMPv6 messages, such as an extended format of the same messages
   <xref target="RFC4884"/> and other messages used by the Neighbor Discovery Protocol <xref target="RFC4861"/>.</t>


<t>ICMPv6 defines a generic message format, which is used to inform the source of IPv6 packets 
of errors during packet delivery. It also specifies messages used by the ping command to test 
connectivity with a  remote node.</t>

<t><xref target="RFC4443"/> instantiates four such error messages:</t>
<ul>
  <li>Destination Unreachable (type = 1),</li>
  <li>Packet Too Big (type = 2), </li> 
  <li> Time Exceeded and </li>
  <li>Parameter Problem.</li>
</ul>
<t><xref target="RFC4443"/> also defines two informational messages,  
the Echo Request (type=128) and Echo Reply messages (type = 129), which provide support for the ping application.</t>


<t>This document describes recommended compression of ICMPv6/IPv6 messages (including header fields and 
structured payload) and extends SCHC by specifying new Field Identifiers for ICMPv6 and two MO and 
two CDA to compress the ICMPv6 payload. This covers different scenarios:</t>

    <ul>
      <li>ICMPv6 messages initiated by SCHC End-Points. They can be sent in their SCHC-compressed 
      form, in ICMPv6 messages traffic. This includes error messages, as well as informational echo 
      request/reply traffic</li>

      <li>ICMPv6 error messages returned from the Internet after End-Point transmission. The core 
      SCHC forwards a compressed version of the error message to the End-Point, including if necessary 
      a compressed payload.</li>

      <li>Traffic coming from the Internet that would generate an error on the End-Point: if it can 
      detect the situation, the SCHC Core directly responds with an ICMPv6 error message, acting as a 
      surrogate to the End-Point.</li>
    </ul>

</section>

<section anchor="terminology" numbered="true" toc="default">
<name>Terminology</name>

<t>This draft re-uses the Terminology defined in <xref target="RFC8724"/>.</t>

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, 
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, 
and “OPTIONAL” in this document are to be interpreted as 
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they 
appear in all capitals, as shown here.</t>

<ul>
  <li>  SCHC Core: SCHC End-Point located at the boundary of a regular IP network 
  and a network that applies SCHC compression and fragmentation</li>

  <li>  SCHC Device: The other end of the SCHC instance formed with the SCHC core.</li>

  <li> Application: entiity sending packets to the SCHC Device or receiving packets from 
  the SCHC Device. The Application may be co-located with the SCHC Core, but is usually 
  located on the regular Internet.</li>

  <li> Regular Internet: Network location carrying uncompressed IPv6 packets. </li>
</ul>

</section>

<section anchor="use-cases">
<name>Use cases</name>

<t>In the following sections, we will describe at <xref target="basicICMPv6"/> ICMPv6 message 
compression for all ICMPv6 messages 
specified in <xref target="RFC4443"/>. We will then extend this basic compression  with a specific 
focus on the following cases:</t>

<ul spacing="normal">
  <li>The Device is the originator of an Echo Request message, and therefore the destination 
  of the Echo  Reply message. 
  These messages are compressed/decompressed by the device and the SCHC 
  Core using SCHC rules that match the ICMPv6 fields (see <xref target="DevicePings"/>).</li>
<!--      
  <li>The Device is the destination of an Echo Request message and therefore the purported source of an Echo Reply message. 
      The SCHC Core can either forward the SCHC-compressed Echo Request message to the Device.
      The proxy answer can be related to the Device observed activity.</li>
 -->     
  <li>The Device should have send an ICMP error message, mainly in response to an incorrect 
  incoming IPv6 message. In this case, as much as possible, the SCHC Core should act on behalf 
  of the Device and originate the Unreachable ICMP Destination message, so that the Device and 
  the network are protected from this unwanted traffic (see <xref target="ProxyErrMsg"/>).</li>
  
  <li>the Device is the destination of the ICMPv6 message, mainly in response to a packet sent 
  by the device to the network that generates an error. In this case, we want the ICMPv6 message 
  to reach the Device, and this document describes in <xref target="ErrMsgCompr"/> what SCHC 
  compression should be applied.
      Since ICMPv6 error messages contain in the payload the original message which has 
      triggered the error, SCHC can compress it using the rules in the reverse direction 
      (see <xref target="device-is-the-destination"/>). </li>
</ul>

</section>

<!--<section anchor="DetailedBehavior" title="Detailed behavior">-->

<section title="ICMPv6 compression" anchor="basicICMPv6">

<t>This section defines ICMPv6 fields that can be compressed by SCHC. <xref target="RFC4443"/> 
defines several formats with respect to the type of the ICMPv6 message.</t>
<t>From them, several fields can be extracted. Note that the names listed here are just informative 
and readability, and the field ID identifiers are specified in the augmentation of the YANG Data Model 
(cf.  <xref target="yang-module"/>):</t>

<t>These fields are present in all the messages: </t>
<ul>
  <li>ICMPv6 Type indicates the fields present in the message.</li>
  <li>ICMPv6 Code is related to the ICMPv6 type and does not have an impact on the message format.</li>
  <li>ICMPv6 Checksum covers the ICMPv6 message and part of the IPv6 header to protect against errors.</li>
  <li>ICMPv6 Payload is part of the ICMPv6 protocol and is not directly originated from upper layers protocols, 
      so this field may be compressed by SCHC at the ICMPv6 level. In the ICMPv6 error message, the payload can 
      be compressed by SCHC compression rules, as it contains the IPv6 message header responsible for the error. 
      For Echo Request and Echo Reply it contains a specific pattern to set the message length. </li>
</ul>

<t>The other fields depends of the message type:</t>
<ul>
  <li>ICMPv6 MTU is used by Packet Too Big message (type = 2) to 
      carry the MTU expected by a node rejecting the packet forwarding </li>
  <li>ICMPv6 Pointer is used by Parameter Problem message to indicate the position 
      of a detected error in the original message </li>
  <li>ICMPv6 Identifier and ICMPv6 Sequence Number are used by ping echo (type 128) and reply (type 129) messages.</li>
</ul>

<!--<t>ICMPv6 is the support for several protocols to configure nodes. These protocols defines new types and 
may add optionnal information after the ICMPv6 header</t>-->

</section>

<section anchor="DevicePings" title="Device does a ping">

<t>A Device may send an Echo Request message to check the availability of the network and the host running the Application. </t>
<t>If a ping Echo Request is generated by a Device, then SCHC compression applies.</t>

<t>The format of an ICMPv6 Echo Request message is described in <xref target="Fig-ICMPv6-Echo-Request"/>, with Type=128 and Code=0.</t>

<figure title="ICMPv6 Echo Request message format" anchor="Fig-ICMPv6-Echo-Request"><artwork><![CDATA[
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Type      |     Code      |          Checksum             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           Identifier          |        Sequence Number        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Data ...
      +-+-+-+-+-

]]></artwork></figure>

<t>If we assume that one rule will be devoted to compressing Echo Request messages, then the Type and Code are known
in the rule to be 128 and 0 and can therefore be elided with the not-sent CDA.</t>

<t>Checksum can be reconstructed with the compute-* CDA and therefore is not transmitted.</t>

<t><xref target="RFC4443"/> states that the identifier and sequence number are meant to
“help in matching Echo Responses to this Echo Request” and that they “may be zero”.
Data are "zero or more bytes of arbitrary data”.</t>

<t>For constrained devices or networks, we recommend that the Identifier be zero, the Sequence Number
be a counter on 3 bits, and the Data be zero bytes (absent). Therefore, Identifier is elided with the 
not-sent CDA, Sequence Number is transmitted on 3 bits with the LSB CDA and no Data is transmitted.</t>

<t>The data part is defined in the rule through the ICMPv6 Payload field. The payload can be sent as 
a residue with a value-sent. It is also possible to elide the data by setting them in the Target 
Value and use a not-sent CDA.</t>


<t>When the destination receives the Echo Request message, it will respond with an Echo Reply message.
This message bears the same format as the Echo Request message but with Type = 129
(see <xref target="Fig-ICMPv6-Echo-Request"/>).</t>

<t><xref target="RFC4443"/> states that the Identifier, Sequence Number, and Data fields of the Echo Reply
message shall contain the same values as the invoking Echo Request message. Therefore, a rule shall be used
similar to that used for compressing the Echo Request message.</t>

<section anchor="rule-example" title="Rule example">

<t>The following rule gives an example of a SCHC compression.
The type can be elided if the direction is taken into account.
Identifier is ignored and generated as 0 at decompression.
This implies that only one single ping can be launched at any given time on a device.
Finally, only the least significant 8 bits of the sequence number are sent on the LPWAN,
allowing a serie of 255 consecutive pings.</t>

<table anchor="Fig-ping-up" align="center">
  <name>Example of compression rule for a ping from the device</name>
  <thead>
    <tr>
      <th align="left">Field</th>
      <th align="left">FL</th>
      <th align="left">FP</th>
      <th align="left">DI</th>
      <th align="left">Value</th>
      <th align="left">Matching Operator</th>
      <th align="left">CDA</th>
      <th align="left"></th>
      <th align="left">Sent bits</th>
    </tr>
  </thead>
  <tbody>
    <tr><td align="center" colspan="9"><em>IPv6 Headers description</em></td></tr>
    <tr>
      <td align="left">ICMPv6 Type</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Up</td>
      <td align="left">128</td>
      <td align="left">equal</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Type</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">129</td>
      <td align="left">equal</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Code</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Bi</td>
      <td align="left">0</td>
      <td align="left">equal</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Identifier</td>
      <td align="left">16</td>
      <td align="left">1</td>
      <td align="left">Bi</td>
      <td align="left">0</td>
      <td align="left">ignore</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Sequence</td>
      <td align="left">16</td>
      <td align="left">1</td>
      <td align="left">Bi</td>
      <td align="left">0</td>
      <td align="left">MSB(13)</td>
      <td align="left">LSB</td>
      <td align="left"></td>
      <td align="left">3</td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Payload</td>
      <td align="left">var</td>
      <td align="left">1</td>
      <td align="left">Bi</td>
      <td align="left">0</td>
      <td align="left">ignore</td>
      <td align="left">value-sent</td>
      <td align="left"></td>
      <td align="left">X</td>
    </tr>
  </tbody>
</table>

<t>The transmission cost of the Echo Request message is therefore the size of the Rule Id + 3 bits and 
the data size increased of the Payload residue size. The rule ID Length
can be chosen to avoid adding padding. </t>
<!--figure title="Example of compression rule for a ping from the device" anchor="Fig-ping-up"><artwork><![CDATA[

 | Field          |FL|FP|DI| Value   | Match  | Comp Decomp|| Sent |
 |                |  |  |  |         | Opera. | Action     ||(bits)|

 |ICMPv6 Type     |8 |1 |Up|128      | equal  | not-sent   ||      |
 |ICMPv6 Type     |8 |1 |Dw|129      | equal  | not-sent   ||      |
 |ICMPv6 Code     |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |ICMPv6 Identif. |16|1 |Bi|0        | ignore | not-sent   ||      |
 |ICMPv6 Sequence |16|1 |Bi|0        | MSB(13)| LSB        ||  3   |
 +================+==+==+==+=========+========+============++======+
]]></artwork></figure-->

<!--<t>NOTE: Add an example where the Payload is also compressed. </t>-->

</section>
</section>

<!--
<section anchor="device-is-pinged" title="Device is ping'ed">

<t>If the Device is ping’ed (i.e., is the destination of an Echo Request message), the 
device receives the compress message and generate an Echo. In that case, the fields
sequence number and identifier cannot be compressed if the source is not aware of 
the compression scheme.</t>


</section>
-->

<section anchor="ProxyErrMsg" title="Device is the source of an ICMPv6 error message">

<t>As stated in <xref target="RFC4443"/>, a node should generate an ICMPv6 message in response to an
IPv6 packet that is malformed or which cannot be processed due to some incorrect field value.</t>

<t>The general intent of this document is to spare both the Device and the LPWAN network this un-necessary traffic.
The incorrect packets should be caught at the SCHC Core and the ICMPv6 notification should be sent back from there.</t>

<figure title="Example of ICMPv6 error message sent back to the Internet" anchor="Fig-ICMPv6-up"><artwork><![CDATA[
     Device       NGW     SCHC Core                    Internet Host

       |           |            |    Destination Port=XXX    |
       |           |            |<---------------------------|
       |           |            |                            |
       |           |            |--------------------------->|
       |           |            | ICMPv6 Port Unreachable    |
       |           |            |                            |
       |           |            |                            |


]]></artwork></figure>

<t><xref target="Fig-ICMPv6-up"/> shows an example of an IPv6 packet trying to reach a Device. </t>

<!-- Let’s assume that the port number used
as destination port is not “known” (needs better definition) from the SCHC Core. 
-->

<t>Let's assume that no rule matches the incoming packet (i.e. there is no co-compression rule)</t>

<t>Instead of sending the packet over
the LPWAN and having this packet rejected by the Device, the SCHC Core issues
an ICMPv6 error message “Destination Unreachable” (Type 1) with Code 1 (“Port Unreachable”) on behalf of the Device.</t>

<t>In that case the SCHC C/D MAY act as a router (i.e. it MUST have a routable IPv6 address to generate
an ICMPv6 message). When compressing a packet containing an IPv6 header, no compression rules are found and:</t>
<ul>
  <li> if a rule contains some extension headers, a parameter problem may be generated (type 4),</li>
  <li> no rule contains the IPv6 device address found in the incoming packet, a no route to destination ICMPv6  message (type 0, code 3) may be generated,</li>
  <!--* a prefix is found, but no devIID matches, a address unreachable ICMPv6  message (type 0, code 3) may be generated,-->
  <li> a device IPv6 address is found, but no port matches,  a port unreachable ICMPv6  message (type 0, code 4) may be generated,</li>
  <li> if the incoming packet is too large for any of the fragmentation rules, an ICMPv6 Message Too big MAY be generated with the largest size allowaed by the fragmentation rules.</li>
</ul>
<!-- LT: I suppress type 0 code 0, if the packet arrives to the SCHC Core, this means that there is a correct prefix. -->
<!--
  <t>TODO: This assumes that all ports that the Device listens to will be matched by a SCHC rule. Is this the basic assumption of SCHC that all packets that do not match a rule are rejected? If yes, why do have fragmentation also for uncompressed packets?</t>
-->
<!--
<t>TODO: discuss the various Type/Code that are expected to be generated in response to various errors.</t>
-->
</section>

<section anchor="device-is-the-destination" title="Device is the destination of an ICMPv6 error message">

<t>In this situation, a Device has been configured to send information to a server on the Internet. If this
server becomes no longer accessible, an ICMPv6 message will be generated back towards the Device by either
an intermediate router or the destination.
This information can be useful to the Device, for example, for reducing the reporting rate in case of periodic
reporting of data.</t>

<t>
Therefore, the ICMPv6 error message should reach the Device. The data inside this error message includes 
the packet at the origin of the error. It should be compressed by the SCHC Core, but in the reverse direction. 
New MOs and CDAs are introduced to perform this operation. The MO check is a rule that matches the Target Value 
in the forward or reverse direction and the CDA performs this compression.</t>

<figure title="Example of ICMPv6 error message sent back to the Device" anchor="Fig-ICMPv6-down"><artwork><![CDATA[
     Device       NGW     SCHC Core                    Internet Server

       |           |            |                            |
       | SCHC compressed IPv6   |                            |
       |~~~~~~~~~~~|----------->|----------------------X     |
       |           |            |<---------------------      |
       |<~~~~~~~~~~|------------| ICMPv6 Host unreachable    |
       |SCHC compressed ICMPv6  | payload: IPv6 packet       |
       |payload: compressed IPv6|                            |
       |           |            |                            |


]]></artwork></figure>

<t><xref target="Fig-ICMPv6-down"/> illustrates this behavior. The ICMPv6 error message is compressed
as described in <xref target="ErrMsgCompr"/> and forwarded over the LPWAN to the Device.</t>

<t>The SCHC returning message contains the SCHC residue of the ICMPv6 message and MAY contain the
compressed original message contained in the ICMP message. The compression can be done by the SCHC Core
by reversing the direction as if this message was issued by the device.</t>

<section anchor="newMO" title="Matching Operator rule match and reverse rule match.">
<t>If the Target Value contains a header, this matching operator returns True if a Rule exists in the 
current Set of Rule to compress it. The selection can either be done:</t>

<ul>
<li> in the same direction of the End-Point, this can be used to compress a protocol encapsulated in the header. </li>
<li> in the reverse direction of the end point, as in an ICMPv6 error message. </li>

</ul>
</section>

<section anchor="newCDA" title="Compression Decompression Actions to compress Target Values.">
<t>These CDAs compress-sent and rev-compress-sent compress the Target Value using rules defined in the current 
Set of Rules. This CDA MUST be used in conjunction 
with the Matching Operators defined in <xref target="newMO"/> according to the direction.  
The compression is using the same direction as the End-Point, the reverse compression uses the opposite direction.</t>

</section>


<section anchor="ErrMsgCompr" title="Example of ICMPv6 error message compression.">

<t>The ICMPv6 error messages defined in <xref target="RFC4443"/> contain the fields shown in
<xref target="Fig-ICMP-error"/>.</t>

<figure title="ICMPv6 Error Message format" anchor="Fig-ICMP-error"><artwork><![CDATA[
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Type      |     Code      |          Checksum             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           Value/Unused                        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    As much of invoking packet                 |
      +                as possible without the ICMPv6 packet          +
      |                exceeding the minimum IPv6 MTU                 |

]]></artwork></figure>

<t><xref target="RFC4443"/> states that Type can take the values 1 to 4, and Code can be set to values between 0 and 6.
Value is unused for the Destination Unreachable and Time Exceeded messages. It contains the MTU for
the Packet Too Big message and a pointer to the byte causing the error for the Parameter Error message.</t>

<t>The payload is viewed as a field. An unsued field MUST not appear in the compressoin rules.</t>

<t>The source address of the message SHOULD be "ignore", since it can be initiated by any router on the path.</t>

<t>The following generic rule can therefore be used to compress all ICMPv6 error messages as defined today.
More specific rules can also be defined to achieve better compression of some error messages.</t>

<t>The Type field can be associated with a matching list [1, 2, 3, 4] and is therefore compressed to 2
bits. Code can be reduced to 3 bits using the LSB CDA. Value can be sent on 11 bits using the LSB
CDA, but if the Device is known to send smaller packets, then the size of this field can
be further reduced.</t>

<t>The first rule example <xref target="Fig-icmp-error1"/> just sends the ICMP type and code as residue to the device.</t>

<table anchor="Fig-icmp-error1" align="center">
  <name>Example of compression rule for a ICMP error to a device</name>
  <thead>
    <tr>
      <th align="left">Field</th>
      <th align="left">FL</th>
      <th align="left">FP</th>
      <th align="left">DI</th>
      <th align="left">Value</th>
      <th align="left">Matching Operator</th>
      <th align="left">CDA</th>
      <th align="left"></th>
      <th align="left">Sent bits</th>
    </tr>
  </thead>
  <tbody>
    <tr><td align="center" colspan="9"><em>IPv6 Headers description</em></td></tr>
    <tr>
      <td align="left">ICMPv6 Type</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">128</td>
      <td align="left">equal</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Code</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">[0,1,2,3,4,5,6]</td>
      <td align="left">match-mapping</td>
      <td align="left">mapping-sent</td>
      <td align="left"></td>
      <td align="left">3</td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Payload</td>
      <td align="left">var</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">0</td>
      <td align="left">ignore</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
  </tbody>
</table>

<t>The second rule example <xref target="Fig-icmp-error2"/> also only sends the ICMP type and code as 
residue to the device, but introduces the new MO "rev-rule match". This MO will check if a rule matches the payload. </t>

<table anchor="Fig-icmp-error2" align="center">
  <name>Example of compression rule for a ICMP error to a device</name>
  <thead>
    <tr>
      <th align="left">Field</th>
      <th align="left">FL</th>
      <th align="left">FP</th>
      <th align="left">DI</th>
      <th align="left">Value</th>
      <th align="left">Matching Operator</th>
      <th align="left">CDA</th>
      <th align="left"></th>
      <th align="left">Sent bits</th>
    </tr>
  </thead>
  <tbody>
    <tr><td align="center" colspan="9"><em>IPv6 Headers description</em></td></tr>
    <tr>
      <td align="left">ICMPv6 Type</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">128</td>
      <td align="left">equal</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Code</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">[0,1,2,3,4,5,6]</td>
      <td align="left">match-mapping</td>
      <td align="left">mapping-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Payload</td>
      <td align="left">var</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">0</td>
      <td align="left">rev-rule-match</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
  </tbody>
</table>

<t>By <xref target="RFC4443"/>, the rest of the ICMPv6 message must contain as much as possible of 
the IPv6 offending (invoking) packet that triggered
this ICMPv6 error message. This information is used to try and identify the SCHC rule that
was used to decompress the offending IPv6 packet. If the rule can be found, then the Rule Id
is added at the end of the compressed ICMPv6 message. Otherwise, the compressed
packet ends with the compressed Value field.</t>

<t>The third rule example <xref target="Fig-icmp-error3"/> also sends the ICMP type, code, and the compresssed payload 
as residue.
It can be noted that this field is identified as "variable" in the rule, which will introduce a size before the IPv6 
compressed header. </t>

<table anchor="Fig-icmp-error3" align="center">
  <name>Example of compression rule for a ICMP error to a device</name>
  <thead>
    <tr>
      <th align="left">Field</th>
      <th align="left">FL</th>
      <th align="left">FP</th>
      <th align="left">DI</th>
      <th align="left">Value</th>
      <th align="left">Matching Operator</th>
      <th align="left">CDA</th>
      <th align="left"></th>
      <th align="left">Sent bits</th>
    </tr>
  </thead>
  <tbody>
    <tr><td align="center" colspan="9"><em>IPv6 Headers description</em></td></tr>
    <tr>
      <td align="left">ICMPv6 Type</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">128</td>
      <td align="left">equal</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Code</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">[0,1,2,3,4,5,6]</td>
      <td align="left">match-mapping</td>
      <td align="left">mapping-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Payload</td>
      <td align="left">var</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">0</td>
      <td align="left">rev-rule-match</td>
      <td align="left">rev-compress-sent</td>
      <td align="left"></td>
      <td align="left">(compressed IPv6 header*9) + 4 or +12</td>
    </tr>
  </tbody>
</table>


</section>
</section>

<!--</section>-->


<section anchor="yang-tree" title="YANG identities and tree">


<t>This YANG module extends Field ID identities to includes fields contained in ICMPv6 header.
Note that the ICMPv6 payload is parsed to the specific field "fid-icmpv6-payload"</t>

<t>
It also defines two new Most identities: </t>

<ul>
  <li>mo-rev-rule-match: The value contained in the Field Value matches a rule. 
      The direction used for matching isthe opposite of the incoming message:
      UP becomes DOWN and DOWN becomes UP.  This MO can be used to test if the Payload
      contained in the ICMPv6 message matches a rule. This means that the 
      original packet, at the origine of the ICMPv6 message, may have been generated
      from the SCHC decompression.</li>
  <li>mo-rule-match: The value contained in the Target Value matches a rule. 
      The direction is the one of the incoming message. This MO is not used 
      for ICMPv6 messages, but since it can be used in other situations, it has 
      been included in the Data Model.</li>
</ul>

<t>The Field Value may be compressed by a rule. The result SHOULD be included in the 
SCHC message as a variable length residue. It contains the Rule ID used by the compression,
the residue, the payload and some padding bits since the variable length init is in bytes.</t>
<ul>
  <li>cda-rev-compress-sent:   The direction used for compression  is the opposite of the incoming message:
      UP becomes DOWN and DOWN becomes UP.  </li>
  <li>cda-compress-sent:   The direction used for compression  is the same as for the incoming message.  </li>

</ul>



</section>

<section anchor="yang-module" title="YANG Module">

<figure title="YANG module" anchor="Fig-yang-module"><artwork><![CDATA[
module ietf-schc-oam {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-schc-oam";
  prefix schc-oam;

  import ietf-schc {
      prefix schc;
  }

  organization
    "IETF IPv6 over Low Power Wide-Area Networks (lpwan) working group";
  contact
    "WG Web:   <https://datatracker.ietf.org/wg/lpwan/about/>
     WG List:  <mailto:p-wan@ietf.org>
     Editor:   Laurent Toutain
       <mailto:laurent.toutain@imt-atlantique.fr>
     Editor:   Ana Minaburo
       <mailto:ana@ackl.io>";
  description
     "
     Copyright (c) 2021 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX
     (https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
     for full legal notices.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
     NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
     'MAY', and 'OPTIONAL' in this document are to be interpreted as
     described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
     they appear in all capitals, as shown here.

     *************************************************************************

     This module extends the ietf-schc module to include the compound-ack 
     behavior for Ack On Error as defined in RFC YYYY. 
     It introduces a new leaf for Ack on Error defining the format of the
     SCHC Ack and add the possibility to send several bitmaps in a single 
     answer.";

  revision 2024-05-19 {
    description
      "Initial version for RFC YYYY ";
    reference
      "RFC YYYY: OAM";
  }

  identity fid-icmpv6-base-type {
    base schc:fid-base-type;
    description
      "Field IP base type for ICMPv6 headers described in RFC 4443";
    reference 
      "RFC 4443   Internet Control Message Protocol (ICMPv6)
                  for the Internet Protocol Version 6 (IPv6) Specification";
  }

// ICMPv6 Fields

  identity fid-icmpv6-type {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 code field present in all ICMPv6 messages.";
  }

  identity fid-icmpv6-code {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 code field present in all ICMPv6 messages.";
  }

  identity fid-icmpv6-checksum {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 checksum field present in all ICMPv6 messages.";
  }

    identity fid-icmpv6-mtu {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 MTU, present in Packet Too Big message.";
  }

  identity fid-icmpv6-pointer {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 Pointer, present in Parameter Problem message.";
  }

  identity fid-icmpv6-identifier {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 identifier field, present in Echo Request/Reply message.";
  }

  identity fid-icmpv6-sequence {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 sequence number field, present in Echo Request/Reply message.";
  }

  identity fid-icmpv6-payload {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 payload following ICMPv6 header.
      If payload is empty, this field exists with a length of 0.";
  }

// MO and CDA

  identity mo-rule-match {
    base schc:mo-base-type;
    description 
        "Macthing operator return true, if the TV matches a rule
        keeping UP and DOWN direction." ;
  }

  identity mo-rev-rule-match {
    base schc:mo-base-type;
    description 
        "Macthing operator return true, if the TV matches a rule
        reversing UP and DOWN direction." ;
  }


  identity cda-compress-sent {
    base schc:mo-base-type;
    description 
        "Send a compressed version of TV keeping UP and 
        DOWN direction." ;
  }

  identity  cda-rev-compress-sent {
    base schc:mo-base-type;
    description 
        "Send a compressed version of TV reversing UP and 
        DOWN direction." ;
  }
}
]]></artwork></figure>


</section>

<section anchor="security-considerations" title="Security considerations">

<t>flood the return path with ICMP error messages.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>TODO</t>

</section>

<section anchor="contributors" title="Contributors">

<t>The following people have been co-authors of precursor versions of this draft.
Their contribution is deeply appreciated and acknowledged.</t>

    <ul>
      <li>Arunprabhu Kandasamy (Acklio)</li> 
      <li>Diego Dujovne (Universidad Diego Portales)</li>
      <li>Juan Carlos Zuniga (Cisco)</li>
    </ul>

</section>

</middle>

<!--  *****BACK MATTER ***** -->
<back>
<!-- References split into informative and normative -->

<!-- There are 2 ways to insert reference entries from the citation libraries:
  1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
  2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
     (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

  Both are cited textually in the same manner: by using xref elements.
  If you use the PI option, xml2rfc will, by default, try to find included files in the same
  directory as the including file. You can also define the XML_LIBRARY environment variable
  with a value containing a set of directories to search.  These can be either in the local
  filing system or remote ones accessed by http (http://domain/dir/... ).-->

  <references>
    <name>References</name>
    <references>
      <name>Normative References</name>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4443.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4861.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4884.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6291.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8174.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8200.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8724.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.9363.xml"?>
    </references>

    <references>
      <name>Informative References</name>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8376.xml"?>
    </references>

<!-- the following is the minimum to make xml2rfc happy
      <reference anchor="min_ref">
        <front>
          <title>Minimal Reference</title>
          <author initials="authInitials" surname="authSurName">
              <organization/>
          </author>
          <date year="2006"/>
        </front>
      </reference>

-->
</references>

<!-- Appendix
<section anchor="app-additional" numbered="true" toc="default">
  <name>Additional Stuff</name>
  <t>This becomes an Appendix.</t>
</section>
-->

</back>
</rfc>
