<?xml version='1.0' encoding='utf-8'?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
    please see http://xml.resource.org/authoring/README.html. -->
<rfc
      xmlns:xi="http://www.w3.org/2001/XInclude"
      category="info"
      docName="draft-barthel-schc-oam-schc-03"
      ipr="trust200902"
      obsoletes=""
      updates=""
      submissionType="IETF"
      xml:lang="en"
      tocInclude="true"
      tocDepth="4"
      symRefs="true"
      sortRefs="true"
      version="3">
  <!-- xml2rfc v2v3 conversion 2.38.1 -->
  <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN" 
    they will automatically be output with "(if approved)" -->

 <!-- ***** FRONT MATTER ***** -->

<front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
        full title is longer than 39 characters -->

  <title abbrev="SCHC ICMPv6 Compression">Static Context Header Compression (SCHC) for the Internet Control Message Protocol (ICMPv6)</title>
  <seriesInfo name="Internet-Draft" value="draft-barthel-schc-oam-schc-03"/>

  <!-- add 'role="editor"' below for the editors if appropriate -->
  <!--author fullname="Dominique Barthel" initials="D." role="editor" surname="Barthel"-->
  <author fullname="Dominique Barthel" initials="D." surname="Barthel">
    <organization></organization>
    <address>
      <postal>
        <country>France</country>
      </postal>
      <email>dominique.barthel@orange.com</email>
    </address>
  </author>

  <author fullname="Laurent Toutain" initials="L." surname="Toutain">
    <organization>IMT Atlantique</organization>
    <address>
      <postal>
        <street>2 rue de la Chataigneraie</street> <street>CS 17607</street>
        <city>Cesson-Sevigne Cedex</city>
        <code>35576</code>
        <country>France</country>
      </postal>
      <email>laurent.toutain@imt-atlantique.fr</email>
    </address>
  </author>

<!--  *****
  <author fullname="Arunprabhu Kandasamy" initials="A." surname="Kandasamy">
    <organization>Acklio</organization>
    <address>
      <postal>
        <street>1137A avenue des Champs Blancs</street>
        <city>Cesson-Sevigne Cedex</city>
        <code>35510</code>
        <country>France</country>
      </postal>
      <email>arun@ackl.io</email>
    </address>
  </author>

  <author fullname="Diego Dujovne" initials="D." surname="Dujovne">
    <organization>Universidad Diego Portales</organization>
    <address>
      <postal>
        <street>Vergara 432</street>
        <city>Santiago</city>
        <code></code>
        <country>Chile</country>
      </postal>
      <email>diego.dujovne@mail.udp.cl</email>
    </address>
  </author>

  <author fullname="Juan Carlos Zuniga" initials="JC." surname="Zuniga">
    <organization>Cisco</organization>
    <address>
      <postal>
        <street></street>
        <city>Montreal QC</city>
        <code></code>
        <country>Canada</country>
      </postal>
      <email>juzuniga@cisco.com</email>
    </address>
  </author>
 ***** -->
 
  <date year="2024"/>
  <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
        in the current day for you. If only the current year is specified, xml2rfc will fill 
	in the current day and month for you. If the year is not the current one, it is 
	necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	specify just the year. -->

  <!-- Meta-data Declarations -->

  <area>Internet</area>
  <workgroup>schc Working Group</workgroup>
  <!-- WG name at the upperleft corner of the doc,
        IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->

  <keyword>template</keyword>
  <!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->

  <abstract>

  <t>This document describes how SCHC can be used to compress and decompress ICMPv6 headers.</t>

<t>This document specifies additional behavior for SCHC <xref target="RFC8724"/> and
extends the YANG Data Model defined in <xref target="RFC9363"/>. It introduces new Field IDs and 
2 MO and 2 CDA to manipulate ICMPv6 payload.</t>
 
  </abstract>
</front>

<middle>
<section anchor="introduction" numbered="true" toc="default">
<name>Introduction</name>


    <t>With IP protocols now generalizing to constrained networks, users expect to perform 
    operation such as ping to ensure device are still active. In the same way, ICMPv6 Error
    Message can be helpful for the Device with may adapt its behavior when the Application
    becomes unreachable. The Application may also benefit of ICMPv6 Error Message produced
    by the SCHC Entity when the compression is not possible.</t>

    <t>However, this requires a little care, because ICMPv6 traffic adds load to the network,
	  and LPWANs could easily be overwhelmed by it.
	  LPWANs’ salient characteristics are described in <xref target="RFC8376"/>.</t>

	<t>The compression described in this document is not limited to traffic over LPWANs but
  can be applied to any kind of networks. The ICMPv6 messages cover by this document are those
  defined in ICMPv6 protocol <xref target="RFC4443"/>. The compression described in this document 
  do not cover other ICMPv6 messages, such as an extended format of the same messages <xref target="RFC4884"/>
  and other messages used by the Neighbor Discovery Protocol <xref target="RFC4861"/>.</t>

<t>ICMPv6 defines a generic message format, used to inform the source of IPv6 packets of errors during packet delivery..</t>
<t><xref target="RFC4443"/> instantiates 4 such error messages:
Destination Unreachable, Packet Too Big, Time Exceeded and Parameter Problem.<xref target="RFC4443"/> also defines 
the Echo Request and Echo Reply messages, which provide support for the ping application.</t>


<t>This document focuses on using Static Context Header Compression (SCHC) to compress <xref target="RFC4443"/> messages.
More specifically, this document describes recommended compression of ICMPv6/IPv6 messages (including header fields and
structured payload) and extends SCHC by specifying new Field Identifiers for ICMPv6 and 2 MO and 2 CDA to compress ICMPv6
payload. This covers different scenarios. Since ICMPv6 is strongly related to IPv6, these scenarios imply 
SCHC entities in charge of compressing/decompression IPv6 called the Device and named after the core SCHC.:</t>

    <ul>
      <li>ICMPv6 messages initiated by the Devices. They can be sent in their SCHC-compressed 
      form like regular Device traffic.</li>

      <li>ICMPv6 error messages returned from the internet after an  Device transmission. The core SCHC forwards
          a compressed version of the error message to the Device.</li>

      <li>traffic coming from the internet that would generate an error at the Device: if it can detect the situation,
	      the core SCHC responds with an ICMPv6 error message, acting as a surrogate to the Device.</li>
    </ul>



</section>

<section anchor="terminology" numbered="true" toc="default">
<name>Terminology</name>

<t>This draft re-uses the Terminology defined in <xref target="RFC8724"/>.</t>

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, 
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, 
and “OPTIONAL” in this document are to be interpreted as 
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they 
appear in all capitals, as shown here.</t>

</section>

<section anchor="use-cases">
<name>Use cases</name>

<t>In the LPWAN architecture, we can distinguish the following cases:</t>

<ul spacing="normal">
  <li>The Device is the originator of an Echo Request message, and therefore the destination of the Echo 
  Reply message. 
      These messages are compressed/decompressed by the device and by the core SCHC using SCHC rules that match the ICMPv6 fields.</li>
  <li>The Device is the destination of an Echo Request message, and therefore the purported source 
  of an Echo Reply message. 
      The core SCHC can either forward the SCHC-compressed Echo Request message to the Device.
      The proxy answer can be related to the Device observed activity.</li>
  <li>The Device should have send an ICMP error message, mainly in response to an incorrect
      incoming IPv6 message. In this case, as much as possible, the core SCHC should act as
      a proxy and originate the ICMP Destination Unreachable message, so that the Device and the 
      network are protected from this unwanted traffic.</li>
  <li>the Device is the destination of the ICMPv6 message, mainly in response to a
      packet sent by the Device to the network that generates an error. In this case, we want the ICMPv6 message
      to reach the Device,
      and this document describes in <xref target="ErrMsgCompr"/> what SCHC compression should be applied.
      Since ICMPv6 Error Messages contains in the payload the orginal message which has triggered the error, SCHC
      can compress it using the rules in the reverse direction. </li>
</ul>

<t>These cases are further described in <xref target="DetailedBehavior"/>.</t>

</section>

<section anchor="DetailedBehavior" title="Detailed behavior">

<section title="ICMPv6 compression">
<t>This section defines ICMPv6 fields that can be compressed by SCHC. {{RFC4443}} defines several 
formats regarding the type of the ICMPv6 message.</t>
<t>From them, several fields can be extracted. Note that names listed here are just informative and lisibility, the 
Field ID identifiers are specified int augmentation of the YANG Data Model (cf.  <xref target="yang-module"/>):</t>

<t>These fields are present in all the messages: </t>
<ul>
  <li>ICMPv6 Type indicates the fields present in the message.</li>
  <li>ICMPv6 Code is related to the ICMPv6 type and has not impact on the message format.</li>
  <li>ICMPv6 Checksum covers the ICMPv6 message and part of the IPv6 header to protect against errors.</li>
  <li>ICMPv6 Payload contains either part of the message at the orgine of the error or some data in the case of ping.</li>
</ul>

<t>The other fields depends of the message type:</t>
<ul>
  <li>ICMPv6 MTU is used by Packet Too Big message (type = 2) to 
      carry the MTU expected by a node rejecting the packet forwarding </li>
  <li>ICMPv6 Pointer is used by Parameter Problem message to indicate the position 
      of a detected error in the original message </li>
  <li>ICMPv6 Identifier and ICMPv6 Sequence Number are used by ping echo (type 128) and reply (type 129) messages.</li>
</ul>

<t>ICMPv6 is the support for several protocols to configure nodes. These protocols defines new types and 
may add optionnal information after the ICMPv6 header</t>

</section>

<section anchor="DevicePings" title="Device does a ping">

<t>A Device may send an Echo Request message to check the availability of the network and of the host running the Application. </t>
<t>If a ping request is generated by a Device, then SCHC compression applies.</t>

<t>The format of an ICMPv6 Echo Request message is described in <xref target="Fig-ICMPv6-Echo-Request"/>, with Type=128 and Code=0.</t>

<figure title="ICMPv6 Echo Request message format" anchor="Fig-ICMPv6-Echo-Request"><artwork><![CDATA[
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Type      |     Code      |          Checksum             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           Identifier          |        Sequence Number        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Data ...
      +-+-+-+-+-

]]></artwork></figure>

<t>If we assume that one rule will be devoted to compressing Echo Request messages, then Type and Code are known 
in the rule to be 128 and 0 and can therefore be elided with the not-sent CDA.</t>

<t>Checksum can be reconstructed with the compute-checksum CDA and therefore is not transmitted.</t>

<t><xref target="RFC4443"/> states that Identifier and Sequence Number are meant to
“aid in matching Echo Replies to this Echo Request” and that they “may be zero”.
Data is “zero or more bytes of arbitrary data”.</t>

<t>For constrained devices or networks, we recommend that Identifier be zero, Sequence Number 
be a counter on 3 bits, and Data be zero bytes (absent). Therefore, Identifier is elided with the 
not-sent CDA, Sequence Number is transmitted on 3 bits with the LSB CDA and no Data is transmitted.</t>

<t>The transmission cost of the Echo Request message is therefore the size of the Rule Id + 3 bits. The rule ID length
can be chosen to avoid adding padding. </t>

<t>When the destination receives the Echo Request message, it will respond back with a Echo Reply message.
This message bears the same format as the Echo Request message but with Type = 129
(see <xref target="Fig-ICMPv6-Echo-Request"/>).</t>

<t><xref target="RFC4443"/> states that the Identifier, Sequence Number and Data fields of the Echo Reply 
message shall contain the same values as the invoking Echo Request message. Therefore, a rule shall be used 
similar to that used for compressing the Echo Request message.</t>

<!--
  <t>TODO: how about a shared rule for Echo Request and Echo Reply with an LSB(1) CDA on the Type field? Or exploiting the Up/Down direction field in the rule?</t>
-->

<section anchor="rule-example" title="Rule example">

<t>The following rule gives an example of a SCHC compression.
The type can be elided if the direction is taken into account.
Identifier is ignored and generated as 0 at decompression.
This implies that only one single ping can be launched at any given time on a device.
Finally, only the least significant 8 bits of the sequence number are sent on the LPWAN,
allowing a serie of 255 consecutive pings.</t>

<table anchor="Fig-ping-up" align="center">
  <name>Example of compression rule for a ping from the device</name>
  <thead>
    <tr>
      <th align="left">Field</th>
      <th align="left">FL</th>
      <th align="left">FP</th>
      <th align="left">DI</th>
      <th align="left">Value</th>
      <th align="left">Matching Operator</th>
      <th align="left">CDA</th>
      <th align="left"></th>
      <th align="left">Sent bits</th>
    </tr>
  </thead>
  <tbody>
    <tr><td align="center" colspan="9"><em>IPv6 Headers description</em></td></tr>
    <tr>
      <td align="left">ICMPv6 Type</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Up</td>
      <td align="left">128</td>
      <td align="left">equal</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Type</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">129</td>
      <td align="left">equal</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Code</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Bi</td>
      <td align="left">0</td>
      <td align="left">equal</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Identifier</td>
      <td align="left">16</td>
      <td align="left">1</td>
      <td align="left">Bi</td>
      <td align="left">0</td>
      <td align="left">ignore</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Sequence</td>
      <td align="left">16</td>
      <td align="left">1</td>
      <td align="left">Bi</td>
      <td align="left">0</td>
      <td align="left">MSB(13)</td>
      <td align="left">LSB</td>
      <td align="left"></td>
      <td align="left">3</td>
    </tr>
  </tbody>
</table>

<!--figure title="Example of compression rule for a ping from the device" anchor="Fig-ping-up"><artwork><![CDATA[

 | Field          |FL|FP|DI| Value   | Match  | Comp Decomp|| Sent |
 |                |  |  |  |         | Opera. | Action     ||(bits)|

 |ICMPv6 Type     |8 |1 |Up|128      | equal  | not-sent   ||      |
 |ICMPv6 Type     |8 |1 |Dw|129      | equal  | not-sent   ||      |
 |ICMPv6 Code     |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |ICMPv6 Identif. |16|1 |Bi|0        | ignore | not-sent   ||      |
 |ICMPv6 Sequence |16|1 |Bi|0        | MSB(13)| LSB        ||  3   |
 +================+==+==+==+=========+========+============++======+
]]></artwork></figure-->

<t>NOTE: Add an example where the Payload is also compressed. </t>

</section>
</section>

<section anchor="device-is-pinged" title="Device is ping'ed">

<t>If the Device is ping’ed (i.e., is the destination of an Echo Request message), the 
device receives the compress message and generate an Echo. In that case, the fields
sequence number and identifier cannot be compressed if the source is not aware of 
the compression scheme.</t>


</section>


<section anchor="ProxyErrMsg" title="Device is the source of an ICMPv6 error message">

<t>As stated in <xref target="RFC4443"/>, a node should generate an ICMPv6 message in response to an
IPv6 packet that is malformed or which cannot be processed due to some incorrect field value.</t>

<t>The general intent of this document is to spare both the Device and the LPWAN network this un-necessary traffic.
The incorrect packets should be caught at the core SCHC and the ICMPv6 notification should be sent back from there.</t>

<figure title="Example of ICMPv6 error message sent back to the Internet" anchor="Fig-ICMPv6-up"><artwork><![CDATA[
     Device       NGW     core SCHC                    Internet Host

       |           |            |    Destination Port=XXX    |
       |           |            |<---------------------------|
       |           |            |                            |
       |           |            |--------------------------->|
       |           |            | ICMPv6 Port Unreachable    |
       |           |            |                            |
       |           |            |                            |


]]></artwork></figure>

<t><xref target="Fig-ICMPv6-up"/> shows an example of an IPv6 packet trying to reach a Device. </t>

<!-- Let’s assume that the port number used
as destination port is not “known” (needs better definition) from the core SCHC. 
-->

<t>Let's assume that no rule matches the incoming packet (i.e. there is no co-compression rule)</t>

<t>Instead of sending the packet over
the LPWAN and having this packet rejected by the Device, the core SCHC issues
an ICMPv6 error message “Destination Unreachable” (Type 1) with Code 1 (“Port Unreachable”) on behalf of the Device.</t>

<t>In that case the SCHC C/D MAY act as a router (i.e. it MUST have a routable IPv6 address to generate
an ICMPv6 message). When compressing a packet containing an IPv6 header, no compression rules are found and:</t>
<ul>
  <li> if a rule contains some extension headers, a parameter problem may be generated (type 4),</li>
  <li> no rule contains the IPv6 device address found in the incoming packet, a no route to destination ICMPv6  message (type 0, code 3) may be generated,</li>
  <!--* a prefix is found, but no devIID matches, a address unreachable ICMPv6  message (type 0, code 3) may be generated,-->
  <li> a device IPv6 address is found, but no port matches,  a port unreachable ICMPv6  message (type 0, code 4) may be generated,</li>
  <li> if the incoming packet is too large for any of the fragmentation rules, an ICMPv6 Message Too big MAY be generated with the largest size allowaed by the fragmentation rules.</li>
</ul>
<!-- LT: I suppress type 0 code 0, if the packet arrives to the core SCHC, this means that there is a correct prefix. -->
<!--
  <t>TODO: This assumes that all ports that the Device listens to will be matched by a SCHC rule. Is this the basic assumption of SCHC that all packets that do not match a rule are rejected? If yes, why do have fragmentation also for uncompressed packets?</t>
-->
<!--
<t>TODO: discuss the various Type/Code that are expected to be generated in response to various errors.</t>
-->
</section>

<section anchor="device-is-the-destination-of-an-icmpv6-error-message" title="Device is the destination of an ICMPv6 error message">

<t>In this situation, we assume that a Device has been configured to send information to a server on the Internet. If this
server becomes no longer accessible, an ICMPv6 message will be generated back towards the Device by either an intermediate router or the destination.
This information can be useful to the Device, for example for reducing the reporting rate in case of periodic reporting of data.
Therefore, we compress the ICMPv6 message using SCHC and forward it to the Device over the LPWAN. We also introduce new MO and CDA
that can be used to test the presence and/or compress the returning payload.</t>

<figure title="Example of ICMPv6 error message sent back to the Device" anchor="Fig-ICMPv6-down"><artwork><![CDATA[
     Device       NGW     core SCHC                    Internet Server

       |           |            |                            |
       | SCHC compressed IPv6   |                            |
       |~~~~~~~~~~~|----------->|----------------------X     |
       |           |            |<---------------------      |
       |<~~~~~~~~~~|------------| ICMPv6 Host unreachable    |
       |SCHC compressed ICMPv6  | payload: IPv6 packet       |
       |payload: compressed IPv6|                            |
       |           |            |                            |


]]></artwork></figure>

<t><xref target="Fig-ICMPv6-down"/> illustrates this behavior. The ICMPv6 error message is compressed
as described in <xref target="ErrMsgCompr"/> and forwarded over the LPWAN to the Device.</t>

<t>The SCHC returning message contains the SCHC residue of the ICMPv6 message and MAY contain the
compressed original message contained in the ICMP message. The compression can be done by the core SCHC
by reversing the direction as if this message was issued by the device.</t>

<section anchor="ErrMsgCompr" title="ICMPv6 error message compression.">

<t>The ICMPv6 error messages defined in <xref target="RFC4443"/> contain the fields shown in
<xref target="Fig-ICMP-error"/>.</t>

<figure title="ICMPv6 Error Message format" anchor="Fig-ICMP-error"><artwork><![CDATA[
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Type      |     Code      |          Checksum             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           Value/Unused                        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    As much of invoking packet                 |
      +                as possible without the ICMPv6 packet          +
      |                exceeding the minimum IPv6 MTU                 |

]]></artwork></figure>

<t><xref target="RFC4443"/> states that Type can take the values 1 to 4, and Code can be set to values between 0 and 6.
Value is unused for the Destination Unreachable and Time Exceeded messages. It contains the MTU for
the Packet Too Big message and a pointer to the byte causing the error for the Parameter Error message.
Therefore, Value is never expected to be greater than 1280 in LPWAN networks.</t>

<t>The payload is viewed as a field. An unsued field MUST not appear in the compressoin rules.</t>

<t>The source address of the message SHOULD be "ignore", since it can be initiated by any router on the path.</t>

<t>The following generic rule can therefore be used to compress all ICMPv6 error messages as defined today.
More specific rules can also be defined to achieve better compression of some error messages.</t>

<t>The Type field can be associated to a matching list [1, 2, 3, 4] and is therefore compressed down to 2
bits. Code can be reduced to 3 bits using the LSB CDA. Value can be sent on 11 bits using the LSB
CDA, but if the Device is known to send smaller packets, then the size of this field can
be further reduced.</t>

<t>The first rule example <xref target="Fig-icmp-error1"/> just sends the ICMP type and code as residue to the device.</t>

<table anchor="Fig-icmp-error1" align="center">
  <name>Example of compression rule for a ICMP error to a device</name>
  <thead>
    <tr>
      <th align="left">Field</th>
      <th align="left">FL</th>
      <th align="left">FP</th>
      <th align="left">DI</th>
      <th align="left">Value</th>
      <th align="left">Matching Operator</th>
      <th align="left">CDA</th>
      <th align="left"></th>
      <th align="left">Sent bits</th>
    </tr>
  </thead>
  <tbody>
    <tr><td align="center" colspan="9"><em>IPv6 Headers description</em></td></tr>
    <tr>
      <td align="left">ICMPv6 Type</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">128</td>
      <td align="left">equal</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Code</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">[0,1,2,3,4,5,6]</td>
      <td align="left">match-mapping</td>
      <td align="left">mapping-sent</td>
      <td align="left"></td>
      <td align="left">3</td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Payload</td>
      <td align="left">var</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">0</td>
      <td align="left">ignore</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
  </tbody>
</table>

<t>The second rule example <xref target="Fig-icmp-error2"/> also only sends the ICMP type and code as residue to the device, 
but it introduces the new MO "rev-rule-match". This MO will check if a rule matches the payload. </t>

<table anchor="Fig-icmp-error2" align="center">
  <name>Example of compression rule for a ICMP error to a device</name>
  <thead>
    <tr>
      <th align="left">Field</th>
      <th align="left">FL</th>
      <th align="left">FP</th>
      <th align="left">DI</th>
      <th align="left">Value</th>
      <th align="left">Matching Operator</th>
      <th align="left">CDA</th>
      <th align="left"></th>
      <th align="left">Sent bits</th>
    </tr>
  </thead>
  <tbody>
    <tr><td align="center" colspan="9"><em>IPv6 Headers description</em></td></tr>
    <tr>
      <td align="left">ICMPv6 Type</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">128</td>
      <td align="left">equal</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Code</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">[0,1,2,3,4,5,6]</td>
      <td align="left">match-mapping</td>
      <td align="left">mapping-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Payload</td>
      <td align="left">var</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">0</td>
      <td align="left">rev-rule-match</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
  </tbody>
</table>

<t>By <xref target="RFC4443"/>, the rest of the ICMPv6 message must contain as much as possible of the IPv6 offending (invoking) packet that triggered
this ICMPv6 error message. This information is used to try and identify the SCHC rule that
was used to decompress the offending IPv6 packet. If the rule can be found then the Rule Id
is added at the end of the compressed ICMPv6 message. Otherwise the compressed
packet ends with the compressed Value field.</t>

<t>The third rule example <xref target="Fig-icmp-error3"/> also sends the ICMP type, code and the compresssed payload as residue.
It can be noted that this field is identified as "variable" in the rule which will introduce a size before the IPv6 compressed header. </t>

<table anchor="Fig-icmp-error3" align="center">
  <name>Example of compression rule for a ICMP error to a device</name>
  <thead>
    <tr>
      <th align="left">Field</th>
      <th align="left">FL</th>
      <th align="left">FP</th>
      <th align="left">DI</th>
      <th align="left">Value</th>
      <th align="left">Matching Operator</th>
      <th align="left">CDA</th>
      <th align="left"></th>
      <th align="left">Sent bits</th>
    </tr>
  </thead>
  <tbody>
    <tr><td align="center" colspan="9"><em>IPv6 Headers description</em></td></tr>
    <tr>
      <td align="left">ICMPv6 Type</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">128</td>
      <td align="left">equal</td>
      <td align="left">not-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Code</td>
      <td align="left">8</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">[0,1,2,3,4,5,6]</td>
      <td align="left">match-mapping</td>
      <td align="left">mapping-sent</td>
      <td align="left"></td>
      <td align="left"></td>
    </tr>
    <tr>
      <td align="left">ICMPv6 Payload</td>
      <td align="left">var</td>
      <td align="left">1</td>
      <td align="left">Dw</td>
      <td align="left">0</td>
      <td align="left">rev-rule-match</td>
      <td align="left">rev-compress-sent</td>
      <td align="left"></td>
      <td align="left">(compressed IPv6 header*9) + 4 or +12</td>
    </tr>
  </tbody>
</table>

<!---
<t><xref target="RFC4443"/> states that the “ICMPv6 error message MUST include as much
of the IPv6 offending (invoking) packet … as possible”.
In order to comply with this requirement, if there is enough information in the incoming ICMPv6 message for the core SCHC to
identify the rule that has been used to decompress the erroneous IPv6 packet, this Rule Id must be
sent in the compressed ICMPv6 message to the Device.
TODO: the erroneous IPv6 packet header (not just the Rule Id) should be sent back. This includes the Rule Id and the compression residue. This means the SCHC C/D uses the context backwards (in the reverse direction). How does the Device know it must also use the context backwards?</t>

<t>TODO: how does one know that the “payload” of a compressed-header packet is in fact another compressed header?</t>
-->
<t>LT: do we add packet too big, for instance if a fragmentation rule cannot handle a size larger than 1280?</t>
</section>
</section>

</section>


<section anchor="yang-tree" title="YANG identities and tree">


<t>This YANG module extends Field ID identities to includes fields contained in ICMPv6 header.
Note that the ICMPv6 payload is parsed to the specific field "fid-icmpv6-payload"</t>

<t>
It also defines two new Most identities: </t>

<ul>
  <li>mo-rev-rule-match: The value contained in the Field Value matches a rule. 
      The direction used for matching isthe opposite of the incoming message:
      UP becomes DOWN and DOWN becomes UP.  This MO can be used to test if the Payload
      contained in the ICMPv6 message matches a rule. This means that the 
      original packet, at the origine of the ICMPv6 message, may have been generated
      from the SCHC decompression.</li>
  <li>mo-rule-match: The value contained in the Target Value matches a rule. 
      The direction is the one of the incoming message. This MO is not used 
      for ICMPv6 messages, but since it can be used in other situations, it has 
      been included in the Data Model.</li>
</ul>

<t>The Field Value may be compressed by a rule. The result SHOULD be included in the 
SCHC message as a variable length residue. It contains the Rule ID used by the compression,
the residue, the payload and some padding bits since the variable length init is in bytes.</t>
<ul>
  <li>cda-rev-compress-sent:   The direction used for compression  is the opposite of the incoming message:
      UP becomes DOWN and DOWN becomes UP.  </li>
  <li>cda-compress-sent:   The direction used for compression  is the same as for the incoming message.  </li>

</ul>



</section>

<section anchor="yang-module" title="YANG Module">

<figure title="YANG module" anchor="Fig-yang-module"><artwork><![CDATA[
module ietf-schc-oam {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-schc-oam";
  prefix schc-oam;

  import ietf-schc {
      prefix schc;
  }

  organization
    "IETF IPv6 over Low Power Wide-Area Networks (lpwan) working group";
  contact
    "WG Web:   <https://datatracker.ietf.org/wg/lpwan/about/>
     WG List:  <mailto:p-wan@ietf.org>
     Editor:   Laurent Toutain
       <mailto:laurent.toutain@imt-atlantique.fr>
     Editor:   Ana Minaburo
       <mailto:ana@ackl.io>";
  description
     "
     Copyright (c) 2021 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX
     (https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
     for full legal notices.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
     NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
     'MAY', and 'OPTIONAL' in this document are to be interpreted as
     described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
     they appear in all capitals, as shown here.

     *************************************************************************

     This module extends the ietf-schc module to include the compound-ack 
     behavior for Ack On Error as defined in RFC YYYY. 
     It introduces a new leaf for Ack on Error defining the format of the
     SCHC Ack and add the possibility to send several bitmaps in a single 
     answer.";

  revision 2024-05-19 {
    description
      "Initial version for RFC YYYY ";
    reference
      "RFC YYYY: OAM";
  }

  identity fid-icmpv6-base-type {
    base schc:fid-base-type;
    description
      "Field IP base type for ICMPv6 headers described in RFC 4443";
    reference 
      "RFC 4443   Internet Control Message Protocol (ICMPv6)
                  for the Internet Protocol Version 6 (IPv6) Specification";
  }

// ICMPv6 Fields

  identity fid-icmpv6-type {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 code field present in all ICMPv6 messages.";
  }

  identity fid-icmpv6-code {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 code field present in all ICMPv6 messages.";
  }

  identity fid-icmpv6-checksum {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 checksum field present in all ICMPv6 messages.";
  }

    identity fid-icmpv6-mtu {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 MTU, present in Packet Too Big message.";
  }

  identity fid-icmpv6-pointer {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 Pointer, present in Parameter Problem message.";
  }

  identity fid-icmpv6-identifier {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 identifier field, present in Echo Request/Reply message.";
  }

  identity fid-icmpv6-sequence {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 sequence number field, present in Echo Request/Reply message.";
  }

  identity fid-icmpv6-payload {
    base schc:fid-icmpv6-base-type;
    description
      "ICMPv6 payload following ICMPv6 header.
      If payload is empty, this field exists with a length of 0.";
  }

// MO and CDA

  identity mo-rule-match {
    base schc:mo-base-type;
    description 
        "Macthing operator return true, if the TV matches a rule
        keeping UP and DOWN direction." ;
  }

  identity mo-rev-rule-match {
    base schc:mo-base-type;
    description 
        "Macthing operator return true, if the TV matches a rule
        reversing UP and DOWN direction." ;
  }


  identity cda-compress-sent {
    base schc:mo-base-type;
    description 
        "Send a compressed version of TV keeping UP and 
        DOWN direction." ;
  }

  identity  cda-rev-compress-sent {
    base schc:mo-base-type;
    description 
        "Send a compressed version of TV reversing UP and 
        DOWN direction." ;
  }
}
]]></artwork></figure>


</section>

<section anchor="security-considerations" title="Security considerations">

<t>flood the return path with ICMP error messages.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>TODO</t>

</section>

<section anchor="contributors" title="Contributors">

<t>The following people have been co-authors of precursor versions of this draft.
Their contribution is deeply appreciated and acknowledged.</t>

    <ul>
      <li>Arunprabhu Kandasamy (Acklio)</li> 
      <li>Diego Dujovne (Universidad Diego Portales)</li>
      <li>Juan Carlos Zuniga (Cisco)</li>
    </ul>

</section>

</middle>

<!--  *****BACK MATTER ***** -->
<back>
<!-- References split into informative and normative -->

<!-- There are 2 ways to insert reference entries from the citation libraries:
  1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
  2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
     (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

  Both are cited textually in the same manner: by using xref elements.
  If you use the PI option, xml2rfc will, by default, try to find included files in the same
  directory as the including file. You can also define the XML_LIBRARY environment variable
  with a value containing a set of directories to search.  These can be either in the local
  filing system or remote ones accessed by http (http://domain/dir/... ).-->

  <references>
    <name>References</name>
    <references>
      <name>Normative References</name>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4443.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4861.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4884.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6291.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8174.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8200.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8724.xml"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.9363.xml"?>
    </references>

    <references>
      <name>Informative References</name>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8376.xml"?>
    </references>

<!-- the following is the minimum to make xml2rfc happy
      <reference anchor="min_ref">
        <front>
          <title>Minimal Reference</title>
          <author initials="authInitials" surname="authSurName">
              <organization/>
          </author>
          <date year="2006"/>
        </front>
      </reference>

-->
</references>

<!-- Appendix
<section anchor="app-additional" numbered="true" toc="default">
  <name>Additional Stuff</name>
  <t>This becomes an Appendix.</t>
</section>
-->

</back>
</rfc>
